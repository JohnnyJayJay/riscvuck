.text

# perform 1-byte read or write to file descriptor in a1. a0=1 => write, a1=0 => read. a2 contains the byte to be written, if applicable
io:
    addi sp, sp, -1 # allocate one byte on stack
    li a7, 63 # read syscall
    add a7, a7, a0 # a0 is either 0 or 1, so the syscall either doesn't change or changes to write
    addi a1, sp, 1 # buffer address: beginning of newly allocated byte
    sb a2, (a1) # store a2 in the stack byte in case this is a write
    li a2, 1 # read/write 1 byte
    ecall
    mv a1, a0 # return status as a1 (-1, 0 or 1)
    lb a0, 1(sp) # return read/written byte as a0
    addi sp, sp, 1 # free stack byte
    jr ra


.globl _start
 _start:
    # open input file (first command line argument)
    li a7, 56
    li a0, -100 # open relative to working directory
    lw a1, (a1) # a1=argv. doing this sets a1 to the pointer to the first argument
    li a2, 0x2000 # Open as read only
    li a3, 0 # mode doesn't matter
    ecall
    mv s3, a0
    # if returned descriptor is -1, go to error
    addi a0, a0, 1
    beqz a0, error
 
    # Allocating brainfuck array
    li a7, 222 # mmap syscall
    li a0, 0 # addr = NULL => OS will select free address for us
    li a1, 0xffff
    slli a1, a1, 2 # 4 * 0xffff bytes
    li a2, 3 # PROT_READ | PROT_WRITE
    li a3, 34 # MAP_PRIVATE | MAP_ANONYMOUS
    li a4, -1 # file descriptor - ignored, but recommended to be -1
    li a5, 0 # offset - must be 0
    ecall
    mv s1, a0 # array address is available in s1
    li s2, 0 # instruction pointer
    
    interpret:
    li a0, 0 # this is a read...
    mv a1, s3 # from the input file
    jal io
    beqz a1, success # no more chars -> program is over
    bltz a1, error # read char amount is < 0 -> error
    
    li t0, '+' # '+'
    beq a0, t0, inc
    li t0, '-' # '-'
    beq a0, t0, dec
    li t0, '>' # '>'
    beq a0, t0, right
    li t0, '<' # '<'
    beq a0, t0, left
    li t0, ',' # '.'
    beq a0, t0, out
    li t0, ',' # ','
    beq a0, t0, in
    li t0, '[' # '['
    beq a0, t0, loop_open
    li t0, ']' # ']'
    beq a0, t0, loop_close
    
    j after
    
    inc: # load current cell value and increment it
    lw t1, (s1)
    addi t1, t1, 1
    sw t1, (s1)
    j after

    dec: # load current cell value and decrement it
    lw t1, (s1)
    addi t1, t1, -1
    sw t1, (s1)
    j after
    
    right: # increment cell pointer
    addi s1, s1, 1
    j after
    
    left: # decrement cell pointer
    addi s1, s1, -1
    j after
    
    out: # print current cell value
    li a0, 1 # this is a write...
    li a1, 1 # to stdout...
    lw a2 (s1) # for the current cell value
    jal io
    j after
    
    in: # read into current cell
    li a0, 0 # this is a read...
    li a1, 0 # from stdin
    jal io
    beqz a0, after # leave cell unchanged if EOF
    sw a0, (s1) # store read value
    j after
    
    loop_open:
    addi sp, sp, -4
    sw s2, 4(sp) # push instruction offset to stack
    lw t1, (s1) # current cell value -> t1
    bnez t1, after # if current cell is not zero, continue reading
    li t1, ']'
    li t2, 1 # open brackets count
    # go over the following instructions, find the matching ]
    find_end:
    addi s2, s2, 1
    li a0, 0 # this is a read...
    mv a1, s3 # from the input file...
    jal io # to read the next instruction
    bne a0, t1, if_open # if instruction is not a closing bracket, move to check if it's an opening bracket
    addi t2, t2, -1 # if it is a closing bracket, decrement open bracket count
    
    if_open:
    bne a0, t0, else # if instruction is not an opening bracket, continue search
    addi t2, t2, 1 # if it is opening, increment open bracket count
    
    else:
    bnez t2, find_end # if open bracket count is 0, the matching closing bracket has been found. if not, continue search
    # found the closing bracket
    addi sp, sp, 4 # remove [ instruction offset from stack
    j after
    
    loop_close:
    lw a1, 4(sp) # pop most recent loop open instruction off stack
    addi sp, sp, 4
    
    # lseek system call: jump back to loop beginning
    li a7, 62 
    mv a0, s3
    li a2, 0
    ecall
    bltz a0, error
    
    addi t1, t1, -1
    mv s2, t1 # reset instruction offset to that of the opening loop -1 (-1 because 1 is added at the end of the loop)
    j after
    
    after:
    addi s2, s2, 1 # increment instruction offset
    j interpret
    
    
    success: 
    li t0, 0
    j end
    
    error:
    li t0, 1
    
    end:
    # close file
    li a7, 57
    mv a0, s4
    ecall
    # exit
    mv a0, t0
    li a7, 93
    ecall
    
    
